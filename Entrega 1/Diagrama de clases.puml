@startuml Diagrama de clases v1
/'
-Fuente estatica deberia estar conectada con el administrador ya que este va a cargar los datasets y agregar un campo que sea a que fuente importa los hechos
-Fuente proxy se vera luego ya que seguro implementa una api para conectarse con otras instancias 
-Las fuentes no obtienen los hechos, a estas se los carga. Habria que brorrar el medoto obtenerHechos de la interfaz y de las clases que la implementan
-Administrador fijarse bien la solicitud de eliminacion ya que esta actuaria sobre la fuente de datos y luego sobre los hechos ver como relacionarlo con cualquier fuente 
-Visualizador solo ve colecciones 
-Chequear bien los metodos que tienen las clases
-Es necesario que administrador, visualizador y contribuyente hereden de persona?
-Consultar si se pueden repetir hechos de otra fuente que no se auna carga por csv, por ejemplo si un contribuyente carga un hecho que ya existe en una fuente dinamica
-Para que esta el metdo filtrar en viusualizador y despues en coleccion.
- esta bien que el hecho tenga un contribuyente? en el caso de las cargas csv no tenemos ese dato ya que viene de una fuente estatica, lo necesitamos ahi?
- La fuente dinamica necesita los contribuyentes? o como los podemos asociar, tambien ya los teniamos cargados en los hechos 
-vamos a tener dos hechos? uno para multimedia y otro para solo texto? 

'/

FuentesDeDatos *-- Coleccion
Hecho -- FuentesDeDatos
Criterio *-- Coleccion
Hecho --* Origen
Contribuyente -- fuenteDinamica
SolicitudEliminacion -- estadoSolicitud
SolicitudEliminacion -- Contribuyente
SolicitudEliminacion -- Hecho
SolicitudEliminacion -- Administrador


class Hecho {
    +titulo: String
    descripcion: String
    categoria: String
    latitud: float
    longitud: float
    fechaHecho: Date
    fechaCarga: Date
    origen: Origen
    ' Se agrega autor para identificar al contribuyente que lo sube o quedar anonimo
    Contribuyente: Contribuyente
    +anonimo: Boolean
    +eliminado: Boolean
    metadata: list <String>
    {method}esIgual(Hecho)
    {method}Actualizar(Hecho)
}

enum Origen{
    CargaManual
    Dataset
    Contribuyente
}

class SolicitudEliminacion{
    hechoAEliminar: Hecho
    Motivo: String
    Estado: estadoSolicitud 
    'por defecto esta en estado pendiente
}

class Persona{
}

class Administrador extends Persona{
    
    {method}crearColeccion(titulo:String,descripcion:String)
    {method}importarHechos(pathACSV:String)
    {method}aceptarSolicitud(solicitudEliminacion)
    {method}rechazarSolicitud(solicitudEliminacion)
    {method}marcarEliminado(Hecho)
    ' no elimina los hechos dentro de la coleccion eliminada
    {method}eliminarColeccion(Coleccion)

    ' para la proxima entrega
    ' {method}etiquetar(Hecho)
    ' {method}revisar(Hecho)
}

class Visualizador extends Persona{
    {method}consultarColeccion(Coleccion)
    {method}filtrar(Coleccion: coleccion,filtro: List<Criterios>): List<Hecho>
}

class Contribuyente extends Visualizador{ 
    ' cualquiera que aporte información
    Nombre: String
    Apellido: String
    Edad: int
    {method}solicitarEliminacion(Hecho)
    {method}agregarHecho(Hecho,anonimidad) 
    'se agrega la anonimidad al crear el hecho
}

interface Criterio{
    
    {method} cumple(Hecho)
}

class CriterioFecha implements Criterio
{
    fechaDesde:Date
    fechaHasta:Date

    {method}cumple(Hecho)
}

class CriterioTitulo implements Criterio
{
    titulo: String
    
    {method}cumple(Hecho)
}

class CriterioDescripcion implements Criterio
{
    Descripcion: String

    {method}cumple(Hecho)
}

class CriterioCategoria implements Criterio
{
    Categoria: String

    {method}cumple(Hecho)
}

class CriterioZona implements Criterio
{
    latitud: float
    longitud: float

    {method}cumple(Hecho)
}

class CriterioOrigen implements Criterio
{
    origen: Origen

    {method}cumple(Hecho)
}

class Coleccion{
    titulo: String
    descripcion: String
    CriterioPertenencia: List<Criterio>
    fuentesDeDatos: FuentesDeDatos
    {method}agregarCriterioPertenencia(Criterio)
    {method}eliminarCriterioPertenencia(Criterio)
    {method}modificarCriterio(Criterio,nuevoCriterio)
    {method}mostrarFiltrado(List<Criterio>)
    {method}filtrarPorCriterios()
}
    
interface FuentesDeDatos{
    nombre : String
    hechos: List<Hecho>
    {method} obtenerHechos()
}
class fuenteEstatica implements FuentesDeDatos{

    {method} obtenerHechos()
}
class fuenteDinamica implements FuentesDeDatos{
    Autores: List<Contribuyente>
    {method} obtenerHechos()
    'solo deberia tener una lista de hechos, los hechos individuales los carga cada contribuyente'
}

class fuenteProxy implements FuentesDeDatos{
    {method} obtenerHechos()
}


enum estadoSolicitud{
    PENDIENTE 
    APROBADA
    RECHAZADA
}


@enduml

@startuml Diagrama de clases v2

skinparam linetype ortho
/'
-Fuente estatica deberia estar conectada con el administrador ya que este va a cargar los datasets y agregar un campo que sea a que fuente importa los hechos
-Fuente proxy se vera luego ya que seguro implementa una api para conectarse con otras instancias 
-Las fuentes no obtienen los hechos, a estas se los carga. Habria que brorrar el medoto obtenerHechos de la interfaz y de las clases que la implementan
-Administrador fijarse bien la solicitud de eliminacion ya que esta actuaria sobre la fuente de datos y luego sobre los hechos ver como relacionarlo con cualquier fuente 
-Visualizador solo ve colecciones 
-Chequear bien los metodos que tienen las clases
-Es necesario que administrador, visualizador y contribuyente hereden de persona?
-Consultar si se pueden repetir hechos de otra fuente que no se auna carga por csv, por ejemplo si un contribuyente carga un hecho que ya existe en una fuente dinamica
-Para que esta el metdo filtrar en viusualizador y despues en coleccion.
- esta bien que el hecho tenga un contribuyente? en el caso de las cargas csv no tenemos ese dato ya que viene de una fuente estatica, lo necesitamos ahi?
- La fuente dinamica necesita los contribuyentes? o como los podemos asociar, tambien ya los teniamos cargados en los hechos 
-vamos a tener dos hechos? uno para multimedia y otro para solo texto? 
'/

/'
Preguntar

Las coincidencia solo puede ser en fuentes estaticas? - 
La responsabilidad de verificar si dfos hechos son iguales es de las fuentes o de los hechos? 

En las coleciones no tenemos mas de una fuente de datos entonces no tiene sentido tener criterio orifgewn
sumando a ese comentario los criterios se pueden aplicar a los hechos o solo se aplican a las colecciones

'/


FuentesDeDatos *-down- Coleccion
Hecho -down- FuentesDeDatos

Criterio *-up- Coleccion
Hecho -left- Multimedia
Multimedia -left- TipoMulti
Contribuyente -left- FuenteDinamica
SolicitudEliminacion -up- EstadoSolicitud
SolicitudEliminacion -right- Contribuyente
SolicitudEliminacion -- Hecho
SolicitudEliminacion -- Administrador

Administrador -left- FuenteEstatica
Visualizador -left- Coleccion
Administrador -down- Coleccion


class Hecho {
    +titulo: String
    descripcion: String
    categoria: String
    latitud: float
    longitud: float
    fechaHecho: Date
    fechaCarga: Date
    fuente: fuenteDeDatos
    +anonimo: Boolean
    +eliminado: Boolean
    multimedia : List<Multimedia>
    metadata: list<String>
    {method}esIgual(Hecho) 'Hay que sacarlo de aca, la responsabilidad deberia ser de la fuente de datos de saber si un hecho es igual al otro, pero los hechos son los que se actualizan
    {method}actualizar(Hecho): void
}
note top of Hecho 
actualizar(Hecho) overridea el que tiene el mismo titulo (solo pasa cuando la fuente es Estatica)
metdata sería útil a futuro tenerla como una clase? deberímos pensar que es una forma de poder filtrar las palabras clave?
end note


enum Origen{
    CargaManual
    Dataset
    Contribuyente
}

note top of Origen 
si se saca del hecho, no romperia la abstraccion?
end note 


class Multimedia{
    tipo: TipoMulti
    url: String
    tamaño: Long
}

note top of Multimedia 
sería útil guardar el tamaño del archivo?
end note

enum TipoMulti{
    FOTO
    VIDEO
    AUDIO
}


class SolicitudEliminacion{
    hechoAEliminar: Hecho
    motivo: String
    estado: estadoSolicitud 
    'por defecto esta en estado pendiente'
}


class Administrador{  
    {method}crearColeccion(titulo:String,descripcion:String)
    {method}importarHechos(pathACSV:String,fuenteEstatica:FuenteEstatica)
    {method}aceptarSolicitud(solicitudEliminacion)
    {method}rechazarSolicitud(solicitudEliminacion)
    {method}solicitarMarcarEliminado(Hecho)
    /' no elimina los hechos dentro de la coleccion eliminada
    {method}eliminarColeccion(Coleccion)

    para la proxima entrega
    {method}etiquetar(Hecho)
    {method}revisar(Hecho) '/
}

class Visualizador{
    {method}consultarColeccion(Coleccion)
    {method}filtrar(Coleccion: coleccion,filtro: List<Criterios>): List<Hecho>
}

class Contribuyente extends Visualizador{ 
    ' cualquiera que aporte información'
    nombre: String
    apellido: String
    edad: int
    {method}solicitarEliminacion(Hecho)
    {method}contribuirHecho(Hecho,anonimidad) 
    'se agrega la anonimidad al crear el hecho'
}
note right of Contribuyente
El hecho se envía a la fuente dinámica para que lo persista.
end note

interface Criterio{
    {method}cumple(Hecho)
}

class CriterioFecha implements Criterio{
    fechaDesde:Date
    fechaHasta:Date

    {method}cumple(Hecho)
}

class CriterioTitulo implements Criterio{
    titulo: String
    
    {method}cumple(Hecho)
}

class CriterioDescripcion implements Criterio{
    descripcion: String

    {method}cumple(Hecho)
}

class CriterioCategoria implements Criterio{
    categoria: String

    {method}cumple(Hecho)
}

class CriterioZona implements Criterio{
    latitud: float
    longitud: float

    {method}cumple(Hecho)
}

class CriterioOrigen implements Criterio{
    origen: fuenteDeDatos

    {method}cumple(Hecho)
}

class Coleccion{
    titulo: String
    descripcion: String
    criterioPertenencia: List<Criterio>
    fuenteDeDatos: FuentesDeDatos
    {method}agregarCriterioPertenencia(Criterio)
    {method}eliminarCriterioPertenencia(Criterio)
    {method}modificarCriterio(Criterio,nuevoCriterio)
    {method}mostrarFiltrado(List<Criterio>)
    {method}filtrarPorCriterios()
}

note right of Coleccion
No contiene hechos.
Consulta hechos desde su fuente de datos y los filtra por criterio.
end note
    
interface FuentesDeDatos{
    nombre : String
    hechos: List<Hecho>
    {method}obtenerAutor(Hecho)
    {method}agregarHecho(Hecho)
}

note right of FuentesDeDatos
Tiene la responsabilidad de persistir los hechos.
Colección los filtra y visualiza, pero no los almacena.
end note

class FuenteEstatica implements FuentesDeDatos{
    {method}agregarHecho(Hecho)
}


class FuenteDinamica implements FuentesDeDatos{
    {method}agregarHecho(Hecho)
}

note top of FuenteDinamica
preguntar si hay solo una fuente dinamica para todos o varias
end note

class FuenteProxy implements FuentesDeDatos{
    {method}agregarHecho(Hecho)    
}

enum EstadoSolicitud{
    PENDIENTE 
    APROBADA
    RECHAZADA
}

@enduml