@startuml Diagrama de clases v3

skinparam linetype ortho
/'
-Fuente estatica deberia estar conectada con el administrador ya que este va a cargar los datasets y agregar un campo que sea a que fuente importa los hechos
-Fuente proxy se vera luego ya que seguro implementa una api para conectarse con otras instancias 
-Las fuentes no obtienen los hechos, a estas se los carga. Habria que brorrar el medoto obtenerHechos de la interfaz y de las clases que la implementan
-Administrador fijarse bien la solicitud de eliminacion ya que esta actuaria sobre la fuente de datos y luego sobre los hechos ver como relacionarlo con cualquier fuente 
-Visualizador solo ve colecciones 
-Chequear bien los metodos que tienen las clases
-Es necesario que administrador, visualizador y contribuyente hereden de persona?
-Consultar si se pueden repetir hechos de otra fuente que no se auna carga por csv, por ejemplo si un contribuyente carga un hecho que ya existe en una fuente dinamica
-Para que esta el metdo filtrar en viusualizador y despues en coleccion.
- esta bien que el hecho tenga un contribuyente? en el caso de las cargas csv no tenemos ese dato ya que viene de una fuente estatica, lo necesitamos ahi?
- La fuente dinamica necesita los contribuyentes? o como los podemos asociar, tambien ya los teniamos cargados en los hechos 
-vamos a tener dos hechos? uno para multimedia y otro para solo texto? 
'/

/'
Preguntar

Las coincidencia solo puede ser en fuentes estaticas? - 
La responsabilidad de verificar si dfos hechos son iguales es de las fuentes o de los hechos? 

En las coleciones no tenemos mas de una fuente de datos entonces no tiene sentido tener criterio orifgewn
sumando a ese comentario los criterios se pueden aplicar a los hechos o solo se aplican a las colecciones

'/


FuenteDeDatos -down-* Coleccion
Hecho *-down- FuenteDeDatos
Criterio -up-* Coleccion
Hecho -left-* Multimedia
Multimedia -left- TipoMulti
Contribuyente -left-> FuenteDinamica
SolicitudEliminacion -up- EstadoSolicitud
SolicitudEliminacion -right- Contribuyente
SolicitudEliminacion *-- Hecho
SolicitudEliminacion <-- Administrador
Administrador -left-* FuenteEstatica
Visualizador -left- Coleccion
Administrador -down-* Coleccion

/'
Tipo	Símbolo	Finalidad
Extensión	<|--	Especialización de una clase en una jerarquía
Implementación	<|..	Realización de una interfaz mediante una clase
Composición	*--	La parte no puede existir sin el todo
Agregación	o--	La parte puede existir independientemente del todo
Dependencia	-->	El objeto utiliza otro objeto
Dependencia	..>	Una forma más débil de dependencia

'/

class Hecho {
    +titulo: String
    descripcion: String
    categoria: String
    latitud: float
    longitud: float
    fechaHecho: Date
    fechaCarga: Date
    fuente: FuenteDeDatos
    +anonimo: Boolean
    +eliminado: Boolean
    multimedia : List<Multimedia>
    metadata: list<String>
    
    {method}getTitulo()
    {method}actualizar(Hecho): void
}
note top of Hecho 
actualizar(Hecho) overridea el que tiene el mismo titulo (solo pasa cuando la fuente es Estatica)
metdata sería útil a futuro tenerla como una clase? deberímos pensar que es una forma de poder filtrar las palabras clave?
end note


class Multimedia{
    tipo: TipoMulti
    url: String
    tamaño: Long
}

note top of Multimedia 
sería útil guardar el tamaño del archivo?
end note

enum TipoMulti{
    FOTO
    VIDEO
    AUDIO
}

class SolicitudEliminacion{
    hechoAEliminar: Hecho
    motivo: String
    estado: EstadoSolicitud 
    'por defecto esta en estado pendiente'
}

class Administrador{  
    {method}crearColeccion(titulo:String,descripcion:String)
    {method}importarHechos(pathACSV:String,fuenteEstatica:FuenteEstatica)
    {method}aceptarSolicitud(solicitudEliminacion)
    {method}rechazarSolicitud(solicitudEliminacion)
    {method}solicitarMarcarEliminado(Hecho)
    /' no elimina los hechos dentro de la coleccion eliminada
    {method}eliminarColeccion(Coleccion)

    para la proxima entrega
    {method}etiquetar(Hecho)
    {method}revisar(Hecho) '/
}

class Visualizador{
    {method}consultarColeccion(Coleccion)
}

class Contribuyente extends Visualizador{ 
    ' cualquiera que aporte información'
    nombre: String
    apellido: String
    edad: int
    {method}solicitarEliminacion(Hecho)
    {method}contribuirHecho(Hecho,anonimidad) 
    'Se planteo tener una lista de solicitudes de eliminacion para poder ver el estado'
}
note right of Contribuyente
El hecho se envía a la fuente dinámica para que lo persista.
end note

interface Criterio{
    {method}cumple(Hecho)
}

class CriterioFecha implements Criterio{
    fechaDesde:Date
    fechaHasta:Date

    {method}cumple(Hecho)
}

class CriterioTitulo implements Criterio{
    titulo: String
    
    {method}cumple(Hecho)
}

class CriterioDescripcion implements Criterio{
    descripcion: String

    {method}cumple(Hecho)
}

class CriterioCategoria implements Criterio{
    categoria: String

    {method}cumple(Hecho)
}

class CriterioZona implements Criterio{
    latitud: float
    longitud: float

    {method}cumple(Hecho)
}

class CriterioOrigen implements Criterio{
    origen: FuenteDeDatos

    {method}cumple(Hecho)
}


note top of Criterio
notamos que podría llegar a ser un caso del patron Composite pero al no tener una jerarquía en Criterio, entendemos que no aplica para este caso
end note

class Coleccion{
    titulo: String
    descripcion: String
    criterioPertenencia: List<Criterio>
    fuenteDeDatos: FuenteDeDatos
    {method}agregarCriterioPertenencia(Criterio)
    {method}eliminarCriterioPertenencia(Criterio)
    {method}modificarCriterio(Criterio,nuevoCriterio)
    {method}filtrarPorCriterios(List<Criterio>)
}

note right of Coleccion
No contiene hechos.
Consulta hechos desde su fuente de datos y los filtra por criterio.
end note
    
interface FuenteDeDatos{
    nombre : String
    hechos: List<Hecho>
    {method}obtenerAutor(Hecho)
    {method}agregarHecho(Hecho)
}

note right of FuenteDeDatos
Tiene la responsabilidad de persistir los hechos.
Colección los filtra y visualiza, pero no los almacena.
end note

class FuenteEstatica implements FuenteDeDatos{
    {method}agregarHecho(Hecho)
    {method}verificarIgualdad(Hecho) 
}


class FuenteDinamica implements FuenteDeDatos{
    {method}agregarHecho(Hecho)
}

note top of FuenteDinamica
preguntar si hay solo una fuente dinamica para todos o varias
end note

class FuenteProxy implements FuenteDeDatos{
    {method}agregarHecho(Hecho)    
}

enum EstadoSolicitud{
    PENDIENTE
    APROBADA
    RECHAZADA
}

@enduml